
#include "allscale/compiler/frontend/allscale_fe_extension.h"

#include <boost/algorithm/string.hpp>

#include "insieme/frontend/clang.h"
#include "insieme/frontend/converter.h"
#include "insieme/frontend/utils/name_manager.h"
#include "insieme/frontend/extensions/interceptor_extension.h"
#include "insieme/core/analysis/ir_utils.h"
#include "insieme/core/lang/reference.h"
#include "insieme/core/transform/node_replacer.h"
#include "insieme/core/transform/materialize.h"
#include "insieme/core/tu/ir_translation_unit_io.h"
#include "insieme/utils/name_mangling.h"
#include "insieme/utils/functional_utils.h"
#include "insieme/utils/iterator_utils.h"

#include "allscale/compiler/lang/allscale_ir.h"
#include "allscale/compiler/utils.h"

namespace iu = insieme::utils;

namespace allscale {
namespace compiler {
namespace frontend {

	void TranslationStateManager::pushState(const TranslationState translationState) {
		translationStates.push_back(translationState);
	}
	void TranslationStateManager::popState() {
		assert_false(translationStates.empty()) << "No TranslationState to pop";
		translationStates.pop_back();
	}
	bool TranslationStateManager::hasState() {
		return !translationStates.empty();
	}
	const TranslationState& TranslationStateManager::getState() {
		assert_false(translationStates.empty()) << "No TranslationState to get";
		return translationStates.back();
	}
	insieme::core::TypePtr TranslationStateManager::getClangTypeMapping(const clang::QualType& clangType) const {
		const clang::Type* type = clangType->getUnqualifiedDesugaredType();
		if(clangTypeMappings.find(type) != clangTypeMappings.end()) {
			return clangTypeMappings.at(type);
		}
		return {};
	}
	const insieme::core::NodeMap& TranslationStateManager::getIrTypeMappings() const {
		return irTypeMappings;
	}
	void TranslationStateManager::addTypeMappings(const clang::QualType& clangType, const insieme::core::TypePtr& targetIrType,
	                                              insieme::frontend::conversion::Converter& converter) {
		// we first have to let the original frontend convert the given clang type
		auto feType = converter.convertType(clangType);
		// now we store the mapping from the type generated by the original frontend to the type generated by us here - if they differ
		if(feType != targetIrType) {
			irTypeMappings[feType] = targetIrType;
		}
		// afterwards we register the mapping from clang type to the desired target type for later lookup
		// Note: This has to happen _after_ the clang type has been translated, otherwise we might only store the identity mapping here
		clangTypeMappings[clangType->getUnqualifiedDesugaredType()] = targetIrType;
	}

	namespace {

		static const char* ALLSCALE_DEPENDENT_TYPE_PLACEHOLDER = "__AllScale__Dependent_AutoType";


		core::ExpressionPtr removeUndesiredRefCasts(const core::ExpressionPtr& input) {
			auto& refExt = input->getNodeManager().getLangExtension<core::lang::ReferenceExtension>();
			if(refExt.isCallOfRefCast(input) || refExt.isCallOfRefKindCast(input)) {
				return core::analysis::getArgument(input, 0);
			}
			return input;
		}

		core::ExpressionPtr derefOrDematerialize(const core::ExpressionPtr& argExprIn) {
			core::IRBuilder builder(argExprIn->getNodeManager());

			auto argExpr = removeUndesiredRefCasts(argExprIn);

			if(auto call = argExpr.isa<core::CallExprPtr>()) {
				if(core::lang::isPlainReference(call->getType())) {
					auto rawCallType = core::analysis::getReferencedType(call->getType());
					return builder.callExpr(rawCallType, call->getFunctionExpr(), call->getArgumentDeclarations());
				}
			}
			auto exprType = argExpr->getType();
			if(core::analysis::isRefType(exprType)) {
				return builder.deref(argExpr);
			}
			return argExpr;
		}

		core::ExpressionPtr prepareTreetureArgument(const core::ExpressionPtr& argExpr) {
			auto exprType = argExpr->getType();
			if(core::analysis::isRefType(exprType) && lang::isTreeture(core::analysis::getReferencedType(exprType))) {
				return derefOrDematerialize(argExpr);
			}
			return argExpr;
		}

		/**
		 * Removes all duplicate call operators in the passed type
		 */
		core::TagTypePtr removeDuplicateCallOperators(const core::TagTypePtr& tagType) {
			return core::transform::transformBottomUpGen(tagType, [](const core::MemberFunctionsPtr& memFuns) {
				core::MemberFunctionList newMemFuns;
				bool alreadyPresent = false;
				for(const auto& memFun : memFuns->getMembers()) {
					if(memFun->getNameAsString() == insieme::utils::getMangledOperatorCallName()) {
						if(alreadyPresent) {
							continue;
						}
						alreadyPresent = true;
					}
					newMemFuns.push_back(memFun);
				}
				return core::IRBuilder(memFuns->getNodeManager()).memberFunctions(newMemFuns);
			});
		}

		/**
		 * Generates a new call operator as a replacement for the given old one.
		 * The new operator will have the correct function type and a matching body which uses the passed recFun argument(s) correctly
		 */
		core::LambdaExprPtr fixCallOperator(const core::LambdaExprPtr& oldOperator, const core::TupleTypePtr& recFunTupleType) {

			auto& mgr = oldOperator->getNodeManager();
			core::IRBuilder builder(mgr);
			auto& refExt = mgr.getLangExtension<core::lang::ReferenceExtension>();
			const auto& oldFunType = oldOperator->getFunctionType();
			core::TypeList funTypeParamTypes(oldFunType->getParameterTypeList());
			core::VariableList params(oldOperator->getParameterList()->getParameters());

			// drop generated params and create mappings
			core::VariableList removedParams;
			for(unsigned i = 0; i < funTypeParamTypes.size() - 2; ++i) {
				funTypeParamTypes.pop_back();
				removedParams.insert(removedParams.begin(), params.back());
				params.pop_back();
			}
			// add recfun tuple type and param
			funTypeParamTypes.push_back(recFunTupleType);
			auto recfunTupleParam = builder.variable(core::transform::materialize(recFunTupleType));
			params.push_back(recfunTupleParam);

			// transform body and replace accesses to the dropped params with the desired accesses to the passed recfun tuple
			auto body = core::transform::transformBottomUpGen(oldOperator->getBody(), [&](const core::CallExprPtr& call) {
				if(refExt.isCallOfRefDeref(call)) {
					auto inner = call->getArgument(0);
					// here we need to replace the call
					// the index of our tuple access relates to the index of the dropped variable in our removedParams list
					auto index = std::find(removedParams.begin(), removedParams.end(), inner) - removedParams.begin();
					if((unsigned) index < removedParams.size()) {
						return builder.accessComponent(builder.deref(recfunTupleParam), index);
					}
				}
				return call;
			});

			auto functionType = builder.functionType(funTypeParamTypes, oldFunType->getReturnType(), core::FK_MEMBER_FUNCTION);
			auto ret = builder.lambdaExpr(functionType, params, body, oldOperator->getReference()->getNameAsString());
			return ret;
		}

		/**
		 * Replaces the call operator operatorLit inside the given tagType with newOperator
		 */
		core::TagTypePtr replaceCallOperator(const core::TagTypePtr& tagType, const core::LiteralPtr& operatorLit, const core::LambdaExprPtr& newOperator) {
			return core::transform::transformBottomUpGen(tagType, [&](const core::MemberFunctionsPtr& memFuns) {
				core::IRBuilder builder(memFuns->getNodeManager());
				core::MemberFunctionList newMemFuns;
				for(const auto& memFun : memFuns->getMembers()) {
					core::ExpressionPtr impl = memFun->getImplementation();
					if(impl == operatorLit) {
						impl = builder.literal(newOperator->getType(), operatorLit->getValue());
					}
					newMemFuns.push_back(builder.memberFunction(memFun->isVirtual(), memFun->getNameAsString(), impl));
				}
				return builder.memberFunctions(newMemFuns);
			});
		}

		core::ExpressionPtr handlePrecCall(const clang::CallExpr* call, insieme::frontend::conversion::Converter& converter,
			                               TranslationStateManager& translationState) {
			assert_eq(call->getNumArgs(), 1) << "handlePrecCall expects 1 argument only";
			auto ret = lang::buildPrec(toVector(converter.convertCxxArgExpr(call->getArg(0))));
			// register type mappings
			translationState.addTypeMappings(call->getCallReturnType(), ret->getType(), converter);
			return ret;
		}

		core::ExpressionPtr handleCoreFunCall(const clang::CallExpr* call, insieme::frontend::conversion::Converter& converter) {

			assert_eq(call->getNumArgs(), 3) << "handleCoreFunCall expects 3 arguments";

			auto& builder = converter.getIRBuilder();
			auto& tMap = converter.getIRTranslationUnit().getTypes();

			// asserts if the passed structType (i.e. the lambda we are translating) doens't have a call operator - i.e. the prec is never called
			auto checkForCallOperator = [&](const core::StructPtr& structType) {
				if(!utils::hasCallOperator(structType)) {
					assert_fail() << "Conversion of prec construct around lambda at \""
							<< insieme::frontend::utils::getLocationAsString(call->getLocStart(), converter.getSourceManager(), false)
							<< "\" failed, because the result is never actually called.";
				}
			};

			// Handle Cutoff

			core::TypePtr paramType = nullptr;
			core::ExpressionPtr cutoffBind = nullptr;
			// simply convert the lambda
			{
				auto cutoffFunClang = call->getArg(0);
				auto cutoffIr = converter.convertExpr(cutoffFunClang);

				auto genType = insieme::core::analysis::getReferencedType(cutoffIr->getType()).as<insieme::core::GenericTypePtr>();
				auto structType = tMap.at(genType)->getStruct();
				checkForCallOperator(structType);
				paramType = utils::extractCallOperatorType(structType)->getParameterType(1);

				auto cutoffClosureType = builder.functionType(paramType, builder.getLangBasic().getBool(), insieme::core::FK_CLOSURE);

				cutoffBind = lang::buildCppLambdaToClosure(cutoffIr, cutoffClosureType);
			}

			// Handle Base Case

			core::TypePtr returnType = nullptr;
			core::ExpressionPtr baseBind = nullptr;
			// simply convert the lambda
			{
				auto baseFunClang = call->getArg(1);
				auto baseIr = converter.convertExpr(baseFunClang);

				auto genType = insieme::core::analysis::getReferencedType(baseIr->getType()).as<insieme::core::GenericTypePtr>();
				auto structType = tMap.at(genType)->getStruct();
				checkForCallOperator(structType);
				returnType = utils::extractCallOperatorType(structType)->getReturnType();

				auto baseClosureType = builder.functionType(paramType, returnType, insieme::core::FK_CLOSURE);

				baseBind = lang::buildCppLambdaToClosure(baseIr, baseClosureType);
			}

			// Handle step case

			core::ExpressionPtr stepBind = nullptr;
			// Here we have to do a bit more work. We convert the lambda and afterwards have to modify it a bit
			{
				auto stepFunClang = call->getArg(2);
				auto stepIr = converter.convertExpr(stepFunClang);

				auto callableTupleType = builder.tupleType(toVector<core::TypePtr>((core::GenericTypePtr)lang::RecFunType(paramType, returnType)));

				core::GenericTypePtr stepReturnType = lang::TreetureType(returnType, false);

				auto stepClosureType = builder.functionType(toVector<core::TypePtr>(paramType, callableTupleType), stepReturnType, insieme::core::FK_CLOSURE);

				stepBind = lang::buildCppLambdaToClosure(stepIr, stepClosureType);

				// first we extract the generated struct
				auto genType = insieme::core::analysis::getReferencedType(stepIr->getType()).as<insieme::core::GenericTypePtr>();
				auto tagType = tMap.at(genType);

				// and remove the duplicate call operators
				auto newTagType = removeDuplicateCallOperators(tagType);

				// now we fix the call operator and replace it with a correctly translated one
				checkForCallOperator(newTagType->getStruct());
				auto oldOperatorLit = utils::extractCallOperator(newTagType->getStruct())->getImplementation().as<core::LiteralPtr>();

				// only fix the operator if it doesn't have the correct tuple type already
				if(!oldOperatorLit->getType().as<core::FunctionTypePtr>()->getParameterType(2).isa<core::TupleTypePtr>()) {
					auto newOperator = fixCallOperator(converter.getIRTranslationUnit()[oldOperatorLit], callableTupleType);
					newTagType = replaceCallOperator(newTagType, oldOperatorLit, newOperator);

					// finally we communicate the changes to the IR-TU
					converter.getIRTranslationUnit().removeFunction(oldOperatorLit);
					converter.getIRTranslationUnit().addFunction(builder.literal(newOperator->getType(), oldOperatorLit->getValue()), newOperator);
				}
				converter.getIRTranslationUnit().replaceType(genType, newTagType);
			}

			return lang::buildBuildRecFun(cutoffBind, toVector(baseBind), toVector(stepBind));
		}

		core::ExpressionPtr handleCoreDoneCall(const clang::CallExpr* call, insieme::frontend::conversion::Converter& converter) {
			return lang::buildTreetureDone(converter.convertCxxArgExpr(call->getArg(0)));
		}

		core::ExpressionPtr handleCoreCombineCall(const clang::CallExpr* call, insieme::frontend::conversion::Converter& converter) {
			assert_eq(call->getNumArgs(), 4) << "handleCoreFunCall expects 3 arguments";

			auto& builder = converter.getIRBuilder();
			auto& tMap = converter.getIRTranslationUnit().getTypes();

			auto argA = prepareTreetureArgument(converter.convertCxxArgExpr(call->getArg(0)));
			auto argATreeture = lang::TreetureType(argA);
			auto argB = prepareTreetureArgument(converter.convertCxxArgExpr(call->getArg(1)));
			auto argBTreeture = lang::TreetureType(argB);

			auto combineIr = converter.convertCxxArgExpr(call->getArg(2));
			auto genType = insieme::core::analysis::getReferencedType(combineIr->getType()).as<insieme::core::GenericTypePtr>();

			auto tagType = tMap.at(genType);
			auto callOperatorType = utils::extractCallOperatorType(tagType->getStruct());
			auto combineLambdaType = builder.functionType(toVector(argATreeture.getValueType(), argBTreeture.getValueType()),
			                                              callOperatorType->getReturnType(), insieme::core::FK_PLAIN);

			auto combineLambda = lang::buildCppLambdaToLambda(combineIr, combineLambdaType);

			return lang::buildTreetureCombine(argA, argB,
			                                  combineLambda,
			                                  converter.convertCxxArgExpr(call->getArg(3)));

			return {};
		}

	}

	boost::optional<std::string> AllscaleExtension::isPrerequisiteMissing(insieme::frontend::ConversionSetup& setup) const {
		if(!setup.hasExtension<insieme::frontend::extensions::InterceptorExtension>()) {
			return std::string("AllscaleExtension requires the InterceptorExtension to be loaded");
		}
		//TODO: ensure that we are running before the interceptor extension
		return {};
	}

	core::ExpressionPtr AllscaleExtension::Visit(const clang::Expr* expr, insieme::frontend::conversion::Converter& converter) {
		// we handle certain calls specially, which we differentiate by their callee's name
		if(auto call = llvm::dyn_cast<clang::CallExpr>(expr)) {
			auto decl = call->getCalleeDecl();
			if(auto funDecl = llvm::dyn_cast_or_null<clang::FunctionDecl>(decl)) {
				auto name = funDecl->getQualifiedNameAsString();

				if(name == "allscale::api::core::prec") {
					return handlePrecCall(call, converter, getTranslationStateManager());
				}
				if(name == "allscale::api::core::fun") {
					return handleCoreFunCall(call, converter);
				}
				if(name == "allscale::api::core::done") {
					return handleCoreDoneCall(call, converter);
				}
				if(name == "allscale::api::core::combine") {
					return handleCoreCombineCall(call, converter);
				}
			}
		}

		return nullptr;
	}

	insieme::core::ExpressionPtr AllscaleExtension::Visit(const clang::CastExpr* castExpr,
	                                                      insieme::core::ExpressionPtr& irExpr, insieme::core::TypePtr& irTargetType,
	                                                      insieme::frontend::conversion::Converter& converter) {
		auto& allscaleExt = irExpr->getNodeManager().getLangExtension<lang::AllscaleModule>();

		// treeture_get has different semantics
		if(castExpr->getCastKind() == clang::CK_LValueToRValue) {
			if(allscaleExt.isCallOfTreetureGet(irExpr)) {
				return irExpr;
			}
		}
		return nullptr;
	}

	insieme::core::TypePtr AllscaleExtension::Visit(const clang::QualType& typeIn, insieme::frontend::conversion::Converter& converter) {
		// Certain type-mappings may have already been determined. Here we do the lookup
		if(auto mappedType = getTranslationStateManager().getClangTypeMapping(typeIn)) {
			return mappedType;
		}

		const clang::Type* type = typeIn->getUnqualifiedDesugaredType();

		if(auto recordType = llvm::dyn_cast<clang::RecordType>(type)) {
			auto recordDecl = recordType->getDecl();
			auto name = recordDecl->getQualifiedNameAsString();
			if(name == "allscale::api::core::fun_def") {
				if(auto specializedDecl = llvm::dyn_cast<clang::ClassTemplateSpecializationDecl>(recordDecl)) {
					core::TypeList templateArgs;
					for(auto a : specializedDecl->getTemplateArgs().asArray()) {
						if(a.getKind() == clang::TemplateArgument::Type) {
							templateArgs.push_back(converter.convertType(a.getAsType()));
							if(templateArgs.size() == 2) { break; }
						}
					}
					assert_eq(templateArgs.size(), 2);
					getTranslationStateManager().pushState(TranslationState{ type, templateArgs[0], templateArgs[1] });
				}
			}
		}

		// if the passed type is an AutoType and is dependent, we can't really translate it correctly.
		// we create a dummy replacement type to move forward in the translation and assert this replacement doesn'T survive in the final IR
		if(auto autoType = llvm::dyn_cast<clang::AutoType>(type)) {
			if(autoType->isDependentType()) { return converter.getIRBuilder().genericType(ALLSCALE_DEPENDENT_TYPE_PLACEHOLDER); }
		}

		return {};
	}

	insieme::core::ExpressionPtr AllscaleExtension::PostVisit(const clang::Expr* expr, const insieme::core::ExpressionPtr& irExpr,
		                                                      insieme::frontend::conversion::Converter& converter) {
		auto& mgr = irExpr->getNodeManager();
		core::IRBuilder builder(mgr);
		auto& basic = mgr.getLangBasic();
		auto& allscaleExt = mgr.getLangExtension<lang::AllscaleModule>();

		if(auto call = irExpr.isa<core::CallExprPtr>()) {
			auto funExpr = call->getFunctionExpr();

			// find prec type instantiation and fix it
			if(auto calleeCall = funExpr.isa<core::CallExprPtr>()) {
				auto innerFunExpr = calleeCall->getFunctionExpr();
				if(basic.isTypeInstantiation(innerFunExpr) && call->getNumArguments() >= 2) {
					auto thisArg = call->getArgument(0);
					if(allscaleExt.isCallOfPrec(thisArg)) {
						return builder.callExpr(thisArg, call->getArgument(1));
					}
				}
			}

			// replace calls to operator() on intercepted types
			{
				auto funTy = funExpr->getType().as<core::FunctionTypePtr>();
				auto funParms = funTy->getParameterTypeList();
				if(funTy->isMemberFunction()) {
					if(auto lit = funExpr.isa<core::LiteralPtr>()) {
						auto name = lit->getStringValue();
						if(call.getNumArguments() == 2) {
							auto thisArg = core::analysis::getArgument(call, 0);
							auto arg = core::analysis::getArgument(call, 1);
							// on prec return value (closure) with simple call
							if(name == iu::mangle("allscale::api::core::detail::prec_operation") + "::" + iu::getMangledOperatorCallName()) {
								// we try to deref the this argument here.
								// This is a rare case where we need to do so, because the semantics for the prec IR type are different
								return builder.callExpr(derefOrDematerialize(thisArg), derefOrDematerialize(arg));
							}
							// on call operator of recfun
							if(name == std::string("recfun::") + insieme::utils::getMangledOperatorCallName()) {
								return builder.callExpr(lang::buildRecfunToFun(derefOrDematerialize(thisArg)), arg);
							}
						}
					}
				}
			}

			// for already translated functions, if they were semantically mapped, don't materialize
			if(core::analysis::isRefType(call->getType())) {
				if(auto referencedType = core::analysis::getReferencedType(call->getType())) {
					if(!core::analysis::isCallOf(funExpr, builder.getLangBasic().getTypeInstantiation())
							&& (lang::isTreeture(referencedType) || lang::isRecFun(referencedType))) {
						return builder.callExpr(referencedType, funExpr, call->getArgumentDeclarations());
					}
				}
			}

			// unwrap type instantiation
			if(auto calleeCall = funExpr.isa<core::CallExprPtr>()) {
				auto innerFunExpr = calleeCall->getFunctionExpr();
				if(basic.isTypeInstantiation(innerFunExpr)) {
					funExpr = core::analysis::getArgument(calleeCall, 1);
				}
			}

			// certain other calls identified by the callee's name get treated differently
			if(auto lit = funExpr.isa<core::LiteralPtr>()) {
				auto name = lit->getStringValue();
				if(name == "treeture::IMP_get") {
					return lang::buildTreetureGet(prepareTreetureArgument(call->getArgument(0)));
				}
				if(name == insieme::utils::mangle("allscale::api::core::run")) {
					return lang::buildTreetureRun(prepareTreetureArgument(call->getArgument(0)));
				}
			}
		}
		return irExpr;
	}

	insieme::core::TypePtr AllscaleExtension::PostVisit(const clang::QualType& typeIn, const insieme::core::TypePtr& irType,
	                                                    insieme::frontend::conversion::Converter& converter) {
		// pop the current TranslationState here in case it was pushed for this clang type. Do this at every exit point
		FinalActions popTranslationState([&]() {
			if(getTranslationStateManager().hasState()) {
				auto state = getTranslationStateManager().getState();
				if(state.clangPointer == typeIn->getUnqualifiedDesugaredType()) {
					getTranslationStateManager().popState();
				}
			}
		});

		// extract relevant type
		const clang::Type* type = typeIn.getTypePtr();
		if(auto autoType = llvm::dyn_cast<clang::AutoType>(type)) {
			if(autoType->isDependentType()) { return irType; }
			if(autoType->isSugared()) { type = autoType->desugar().getTypePtr(); }
			if(autoType->isDeduced()) { type = autoType->getDeducedType().getTypePtr(); }
		}
		if(auto injectedType = llvm::dyn_cast<clang::InjectedClassNameType>(type)) {
			type = injectedType->getInjectedSpecializationType().getTypePtr();
		}
		type = type->getUnqualifiedDesugaredType();

		// extract type name from clang type
		std::string typeName;
		if(auto tempSpecType = llvm::dyn_cast<clang::TemplateSpecializationType>(type)) {
			if(auto templateDecl = tempSpecType->getTemplateName().getAsTemplateDecl()) {
				typeName = templateDecl->getQualifiedNameAsString();
			}
		}
		if(auto tagType = llvm::dyn_cast<clang::TagType>(type)) {
			typeName = tagType->getDecl()->getQualifiedNameAsString();
		}

		// handle conversion
		if(typeName == "allscale::api::core::detail::completed_task" || typeName == "allscale::api::core::impl::reference::treeture"
				|| typeName == "allscale::api::core::impl::reference::unreleased_treeture"
				|| typeName == "allscale::api::core::impl::sequential::lazy_unreleased_treeture") {
			auto innerType = irType.as<core::GenericTypePtr>()->getTypeParameter(0);
			if(core::analysis::isRefType(innerType)) { innerType = core::analysis::getReferencedType(innerType); }
			return (core::GenericTypePtr) lang::TreetureType(innerType, false);
		}
		if(boost::starts_with(typeName, "allscale::api::core::detail::callable")) {
			auto translationState = getTranslationStateManager().getState();
			return (core::GenericTypePtr) lang::RecFunType(translationState.paramType, translationState.returnType);
		}

		return irType;
	}

	std::pair<core::VariablePtr, core::ExpressionPtr> AllscaleExtension::PostVisit(const clang::VarDecl* varDecl, const core::VariablePtr& var,
		                                                                           const core::ExpressionPtr& varInit,
		                                                                           insieme::frontend::conversion::Converter& converter) {
		core::IRBuilder builder(var->getNodeManager());

		// not all VarDecls also have an initialization
		if(varInit) {
			// Change variable type for calls to AllScale API functions
			auto initT = varInit->getType();
			if(core::analysis::isRefType(initT)) initT = core::analysis::getReferencedType(initT);

			auto replacementBuilder = [&builder](const core::TypePtr& varT, const core::TypePtr& initT, const core::ExpressionPtr& varInit) {
				assert_true(core::analysis::isRefType(varT));
				auto varRefT = core::lang::ReferenceType(varT);
				varRefT.setElementType(initT);
				return std::make_pair(builder.variable((core::GenericTypePtr)varRefT), varInit);
			};

			// handle prec call result
			if(auto funT = initT.isa<core::FunctionTypePtr>()) {
				if(funT->getKind() == core::FK_CLOSURE) {
					auto retT = funT->getReturnType();
					if(lang::isTreeture(retT)) {
						return replacementBuilder(var->getType(), initT, varInit);
					}
				}
			}

			// handle treetures
			if(lang::isTreeture(initT)) {
				return replacementBuilder(var->getType(), initT, removeUndesiredRefCasts(varInit));
			}
		}
		return {var, varInit};
	}

	insieme::core::tu::IRTranslationUnit AllscaleExtension::IRVisit(insieme::core::tu::IRTranslationUnit& tu) {
		// we need to replace certain types which have been translated by the interceptor or the insieme frontend with the result types we translated here
		auto& mgr = tu.getNodeManager();
		core::IRBuilder builder(mgr);
		auto& refExt = mgr.getLangExtension<core::lang::ReferenceExtension>();

		auto ir = core::tu::toIR(mgr, tu);
		auto resultIr = core::transform::replaceAllGen(mgr, ir, getTranslationStateManager().getIrTypeMappings(), core::transform::globalReplacement);

		// insert treeture_to_ref calls where necessary
		resultIr = core::transform::transformBottomUpGen(resultIr, [&builder, &refExt](const core::CallExprPtr& call) {
			auto callee = call->getFunctionExpr();
			if(!core::lang::isBuiltIn(callee)) { return call; }

			core::TypeList params = callee->getType().as<core::FunctionTypePtr>()->getParameterTypeList();
			core::ExpressionList args = call->getArgumentList();
			core::ExpressionList newArgs;

			for(auto pair : make_paired_range(params, args)) {
				auto paramType = pair.first;
				auto arg = pair.second;
				if(core::analysis::isRefType(paramType) && !core::analysis::isRefType(arg) && lang::isTreeture(arg)) {
					newArgs.push_back(lang::buildTreetureToRef(arg, paramType));

				} else {
					newArgs.push_back(arg);
				}
			}

			return builder.callExpr(call->getType(), callee, newArgs);
		}, core::transform::globalReplacement);

		return core::tu::fromIR(resultIr);
	}

	insieme::core::ProgramPtr AllscaleExtension::IRVisit(insieme::core::ProgramPtr& prog) {
		core::IRBuilder builder(prog->getNodeManager());

		// temporarily dump the generated IR in a readable format
		//dumpReadable(prog);

		// make sure that we don't have the dummy dependent type replacement type in the program anywhere anymore
		assert_eq(core::analysis::countInstances(prog, builder.genericType(ALLSCALE_DEPENDENT_TYPE_PLACEHOLDER), false), 0);

		// also make sure we don't have any leftover state on our stack
		assert_false(getTranslationStateManager().hasState());

		return prog;
	}
}
}
}

