#include "allscale/compiler/core/allscale_core.h"

#include <ctime>

#include <fstream>
#include <sstream>

#include <boost/algorithm/string/replace.hpp>
#include <boost/property_tree/json_parser.hpp>

#include "insieme/core/annotations/source_location.h"
#include "insieme/core/checks/full_check.h"

#include "allscale/compiler/config.h"
#include "allscale/compiler/core/cpp_lambda_to_ir_conversion.h"
#include "allscale/compiler/core/global_constant_propagation.h"
#include "allscale/compiler/core/data_item_conversion.h"
#include "allscale/compiler/core/prec_to_work_item_conversion.h"

namespace allscale {
namespace compiler {
namespace core {

	boost::property_tree::ptree toPropertyTree(const ConversionReport& report) {

		// conversions + issues
		boost::property_tree::ptree conversions;
		for(const auto& p : report.issues) {
			boost::property_tree::ptree entry;

			// original target
			auto target = p.first;
			entry.push_back(make_pair("loc", reporting::locationToPropertyTree(target)));

			// locating user code
			{
				using namespace insieme::core;

				auto binding = target.getFirstParentOfType(NodeType::NT_LambdaBinding).as<LambdaBindingAddress>();
				while(binding) {
					auto lambdaexpr = binding.getFirstParentOfType(NodeType::NT_LambdaExpr);

					if(auto location = annotations::getLocation(lambdaexpr)) {
						if(!containsSubString(location->getFile(), "include/allscale/api")) {
							// found user code
							entry.push_back(make_pair("loc_user", reporting::locationToPropertyTree(lambdaexpr)));
							break;
						}
					}

					binding = binding.getParentAddress().getFirstParentOfType(NodeType::NT_LambdaBinding).as<LambdaBindingAddress>();
				}
			}

			entry.push_back(make_pair("issues", toPropertyTree(p.second.first)));

			boost::property_tree::ptree variant_issues;
			{
				int variant_counter = 0;
				for(const auto& pp : p.second.second) {
					variant_issues.push_back(make_pair(toString(++variant_counter), toPropertyTree(pp.second)));
				}
			}
			entry.push_back(make_pair("variant_issues", variant_issues));

			conversions.push_back(make_pair(toString(target), entry));
		}

		// collect help messages
		boost::property_tree::ptree help_messages;
		{
			std::set<reporting::ErrorCode> errors;
			for(const auto& p : report.issues) {
				for (const auto& issue : p.second.first) {
					errors.insert(issue.getErrorCode());
				}
				for(const auto& pp : p.second.second) {
					for(const auto& issue : pp.second) {
						errors.insert(issue.getErrorCode());
					}
				}
			}

			for (const auto& err : errors) {
				if (auto msg = reporting::lookupHelpMessage(err)) {
					help_messages.put<string>(toString(err), *msg);
				}
			}
		}

		boost::property_tree::ptree ret;
		ret.push_back(make_pair("conversions", conversions));
		ret.push_back(make_pair("help_messages", help_messages));
		return ret;
	}

	void toJSON(const std::string& filename, const ConversionReport& report) {
		write_json(filename, toPropertyTree(report));
	}

	void toJSON(std::ostream& out, const ConversionReport& report) {
		write_json(out, toPropertyTree(report));
	}

	void toHTML(const std::string& filename, const ConversionReport& report) {
		auto report_template = getAllscaleBuildRootDir() + "/report.out.html"; // generated by CMake
		std::ifstream in(report_template);
		assert_true(in)  << "could not open template for conversion report";
		in >> std::noskipws;

		std::ofstream out(filename);
		assert_true(out) << "could not open output file for conversion report";

		std::stringstream report_buffer;
		write_json(report_buffer, toPropertyTree(report));

		std::stringstream timestamp;
		{
			std::time_t t = std::time(nullptr);
			timestamp << std::asctime(std::localtime(&t));
		}

		while(in) {
			std::string line;
			std::getline(in, line);

			boost::replace_all(line, "%REPORT%",   report_buffer.str());
			boost::replace_all(line, "%DATETIME%", timestamp.str());

			out << line << "\n";
		}
	}

	std::ostream& operator<<(std::ostream& out, const ConversionReport& report) {

		out << "\n";
		out << " ------ AllScale Code Generation Report ------\n";

		out << "  Number of processed parallel regions: " << report.issues.size() << "\n";

		out << " ---------------------------------------------\n";

		int region_counter = 0;
		for(const auto& p : report.issues) {
			const auto& issues = p.second.first;
			const auto& variants = p.second.second;

			out << "Processed parallel region #" << (++region_counter) << ":\n";

			// output issues not associated with a specific variant
			for(const auto& issue : issues) {
				out << "\t" << issue << "\n";
			}

			// output issues associated with a specific variant
			int variant_counter = 0;
			for(const auto& pp : variants) {
				const auto& issues = pp.second;

				out << "\tVariant #" << (++variant_counter) << "\n";
				for(const auto& issue : issues) {
					out << "\t\t" << issue << "\n";
				}
			}

		}

		out << " ---------------------------------------------\n";

		return out;
	}

	ConversionResult convert(const insieme::core::NodePtr& code, const ProgressCallback& callback) {

		// make sure the input is correct
		assert_correct_ir(code);

		// Step 1: convert C++ lambdas to IR
		callback(ProgressUpdate("Pre-processing C++ lambdas ..."));
		auto res = convertCppLambdaToIR(code);

		// Step 2: performing global constant propagation
		callback(ProgressUpdate("Propagating global constants ..."));
		res = propagateGlobalConstants(res);

		// Step 3: introduce data item references
		res = convertDataItemReferences(res, callback);

		// Step 4: convert prec calls
		auto precConversionResult = convertPrecToWorkItem(res, callback);
		res = precConversionResult.result;

		// Step 5: convert the entry point into a work item
		// TODO: move this step from the backend to the core

		// Step 6: add default constructors to all closure types
		// TODO: move this step from the backend to the core

		// make sure the result is correct
		assert_correct_ir(res);

		return { precConversionResult.report, res };
	}

} // end namespace core
} // end namespace compiler
} // end namespace allscale
